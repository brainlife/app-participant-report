{"version":3,"file":"index.547fd6cf.js","sources":["../../vite/modulepreload-polyfill","../../src/components/SurfaceController.vue","../../src/components/TractController.vue","../../src/App.vue","../../src/assets/controls.png","../../src/main.ts"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","<script lang=\"ts\">\n\nimport { defineComponent, PropType } from 'vue'\n\nimport { ISurfaceLR } from '../interfaces'\n\nimport PerfectScrollbar from 'perfect-scrollbar'\nimport 'perfect-scrollbar/css/perfect-scrollbar.css'\n\nexport default defineComponent({\n    props: {\n        surfaces: {\n            type: Object as PropType<{[key: string]: ISurfaceLR}>,\n            required: true\n        }\n    },\n\n    mounted() {\n        // @ts-ignore\n        new PerfectScrollbar(this.$refs.surfaces);\n    },\n    methods: {\n        color(surface: ISurfaceLR) {\n            if(surface.left) return surface.left.color.getStyle();\n            if(surface.right) return surface.right.color.getStyle();\n        },\n        \n        menuitementer(tract: ISurfaceLR) {\n            //console.log(\"TractController mouseenter\", tract);\n            this.$emit(\"menuitementer\", tract);\n        },\n        menuitemleave(tract: ISurfaceLR) {\n            this.$emit(\"menuitemleave\", tract);\n        },\n    \n        check(obj: ISurfaceLR, left: boolean) {\n            if(!obj) return;\n            if(left) {\n                if(obj.left && obj.left.mesh) obj.left.mesh.visible = obj.left_check;\n            } else {\n                if(obj.right && obj.right.mesh) obj.right.mesh.visible = obj.right_check;\n            }\n            this.$emit(\"update\");\n        },\n\n    }\n});\n\n</script>\n\n<template>   \n<div class=\"controls\">\n    <div class=\"control-row\" style=\"margin: 8px 0px; position: relative;\">\n        <b class=\"check check-left\">&nbsp;L&nbsp;</b>\n        <b class=\"check check-right\">&nbsp;R&nbsp;</b>\n        <h2>Brain Regions</h2>\n    </div>\n    <div class=\"scrollable\" ref=\"surfaces\">\n        <div v-if=\"surfaces\">\n            <div v-for=\"name in Object.keys(surfaces)\" :key=\"name\"\n                    :style=\"{color: color(surfaces[name])}\" \n                    class=\"control-row\"\n                @mouseenter=\"menuitementer(surfaces[name])\" \n                @mouseleave=\"menuitemleave(surfaces[name])\">\n                {{name}}\n                <input v-if=\"surfaces[name].left?.mesh\" type='checkbox' class=\"check check-left\" @change=\"check(surfaces[name], true)\" v-model='surfaces[name].left_check' />\n                <input v-if=\"surfaces[name].right?.mesh\" type='checkbox' class=\"check check-right\" @change=\"check(surfaces[name], false)\" v-model='surfaces[name].right_check' />\n            </div>\n        </div>\n    </div>\n    <br>\n</div>\n</template>","<script lang=\"ts\">\n\nimport { defineComponent, PropType } from 'vue'\n\nimport { ITractLR } from '../interfaces'\n\nimport PerfectScrollbar from 'perfect-scrollbar'\nimport 'perfect-scrollbar/css/perfect-scrollbar.css'\n\nexport default defineComponent({\n    props: {\n        tracts: {\n            type: Object as PropType<{[key: string]: ITractLR}>,\n            required: true\n        }\n    },\n    data() {\n        return {\n            all_left: false,\n            all_right: false,\n        }\n    },\n    computed: {\n        sorted_tracts: function() {\n            if(!this.tracts) return [];\n            return Object.keys(this.tracts).sort();\n        }\n    },\n    mounted() {\n        // @ts-ignore\n        new PerfectScrollbar(this.$refs.tracts);\n    },\n    watch: {\n        all_left: function(v) {\n            for(let name in this.tracts) {\n                let tract = this.tracts[name] as ITractLR;\n                if(tract.left?.mesh) {\n                    tract.left_check = v;   \n                    tract.left.mesh.visible = v;\n                }\n            }\n            this.$emit(\"update\");\n        },\n\n        all_right: function(v) {\n            for(let name in this.tracts) {\n                let tract = this.tracts[name] as ITractLR;\n                if(tract.right?.mesh) {\n                    tract.right_check = v;  \n                    tract.right.mesh.visible = v;\n                }\n            }\n            this.$emit(\"update\");\n        },\n    },\n\n    methods: {\n        color(tract: ITractLR) {\n            if(tract.left) return tract.left.color.getStyle();\n            if(tract.right) return tract.right.color.getStyle();\n        },\n        \n        menuitementer(tract: ITractLR) {\n            this.$emit(\"menuitementer\", tract);\n        },\n        menuitemleave(tract: ITractLR) {\n            this.$emit(\"menuitemleave\", tract);\n        },\n    \n        check(obj: ITractLR, left: boolean) {\n            if(!obj) return;\n            if(left) {\n                if(obj.left?.mesh) obj.left.mesh.visible = obj.left_check;\n            } else {\n                if(obj.right?.mesh) obj.right.mesh.visible = obj.right_check;\n            }\n            this.$emit(\"update\");\n        },\n    },\n});\n\n</script>\n\n<template>   \n<div class=\"controls\">\n    <div class=\"control-row\" style=\"margin: 8px 0px; position: relative;\">\n        <b class=\"check check-left\">&nbsp;L&nbsp;</b>\n        <b class=\"check check-right\">&nbsp;R&nbsp;</b>\n        <h2>White Matter Tracts</h2>\n    </div>\n\n    <div class=\"scrollable\" ref=\"tracts\">\n        <div v-if=\"tracts\">\n            <div class=\"control-row\" style=\"border-bottom: 1px solid #fff3; padding-bottom: 5px; margin-bottom: 5px\">\n                <b style=\"opacity: 0.3; position: relative;\">All</b>\n                <input type='checkbox' v-model='all_left' class=\"check check-left\"/>\n                <input type='checkbox' v-model='all_right' class=\"check check-right\"/>\n            </div>\n\n            <div v-for=\"name in sorted_tracts\" :key=\"name\"\n                :style=\"{color: color(tracts[name])}\" \n                class=\"control-row\" style=\"position: relative;\"\n                @mouseenter=\"menuitementer(tracts[name])\" \n                @mouseleave=\"menuitemleave(tracts[name])\">\n                {{name}}\n                <input v-if=\"tracts[name].left?.mesh\" type='checkbox' class=\"check check-left\" \n                    @change=\"check(tracts[name], true)\" \n                    v-model='tracts[name].left_check' />\n                <input v-if=\"tracts[name].right?.mesh\" type='checkbox' class=\"check check-right\" \n                    @change=\"check(tracts[name], false)\" \n                    v-model='tracts[name].right_check' />\n            </div>\n        </div>\n    </div>\n</div>\n</template>\n\n<style scoped>\n.controls {\n    right: 0;\n}\n\n</style>","<script lang=\"ts\">\n\nimport { defineComponent, defineAsyncComponent } from 'vue'\n\nimport SurfaceController from './components/SurfaceController.vue'\nimport TractController from './components/TractController.vue'\n\nimport * as THREE from 'three'\n\nimport { ITractConfig, ISurfaceConfig, ISurfaceLR, ITractLR } from './interfaces'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n\nimport { VTKLoader } from 'three/examples/jsm/loaders/VTKLoader.js'\n\n// @ts-ignore\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'\n\n// @ts-ignore\nimport * as Stats from 'stats.js/build/stats.min.js'\n\n//we can't store threejs elements here as vue3's proxied object interfares with threejs's proxied object\nconst three = {\n    scene: new THREE.Scene(),\n    //back_scene: new THREE.Scene(),\n    renderer: new THREE.WebGLRenderer({ alpha: true, antialias: true }),\n    camera: new THREE.PerspectiveCamera(45, 2.0, 1, 5000), //will be resized in initScene()\n    camera_light: new THREE.PointLight(0xffeedd, 0.7),\n    raycaster: new THREE.Raycaster(),\n}\n\nexport default defineComponent({\n\n    data() {\n        return {\n            config: {\n                tracts: null as ITractConfig[]|null,\n                surfaces: null as ISurfaceConfig[]|null,\n                debug: (process.env.NODE_ENV == \"development\")?true:false,      \n            },\n            controls: {\n                orbit: null as OrbitControls|null,\n                showStart: false,\n                showEnd: false,\n            },\n\n            tracts: {} as {[key: string]: ITractLR},\n            surfaces: {} as {[key: string]: ISurfaceLR},\n\n            //below are things that we haven't touched yet.\n            load_percentage: 1,\n            loading: null as (null|string),\n\n            pushed_surface: null as ISurfaceConfig|null,\n            \n            hoveredLR: null as ISurfaceLR|ITractLR|null,//on the list\n\n            tooltip: \"\",\n            tooltipBounce: null as null|ReturnType<typeof setTimeout>,\n            stats: null as null | typeof Stats, //for fps\n        }\n    },\n\n    mounted() {\n        //handle config params\n        // @ts-ignore (we inject config via window.parent.config which is not standard)\n        let config = window.parent.config || window.config;\n\n        if(config) {\n            //normalize a case where there is only 1 surface / tract object (some app does that..)\n            if(config.tracts && !Array.isArray(config.tracts)) config.tracts = [config.tracts];\n            if(config.surfaces && !Array.isArray(config.surfaces)) config.surfaces = [config.surfaces];\n\n            this.config.tracts = config.tracts;\n            this.config.surfaces = config.surfaces;\n\n            //append jwt to config.\n            let jwt = localStorage.getItem(\"jwt\");\n            if(jwt && this.config.tracts) this.config.tracts.forEach((tract:ITractConfig)=>{\n                tract.url += \"?at=\"+jwt;\n            });\n            if(jwt && this.config.surfaces) this.config.surfaces.forEach((surface:ISurfaceConfig)=>{\n                surface.url += \"?at=\"+jwt;\n            });\n\n            //let vue initialize the main with now that we have this.config.tracts\n            this.$nextTick(()=>{\n                this.init();\n            });\n        } else {\n            this.loadDemoConfig();\n        }\n    },\n\n    destroyed() {\n        window.removeEventListener(\"resize\", this.resize);\n    },\n\n    watch: {\n        \"controls.showStart\": function() {\n            this.updateVisibility();\n        },\n        \"controls.showEnd\": function() {\n            this.updateVisibility();\n        },\n    },\n\n    methods: {\n\n        async init() {\n            // @ts-ignore\n            THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\n            // @ts-ignore\n            THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n            THREE.Mesh.prototype.raycast = acceleratedRaycast;\n\n            //initialize Stats to show debug info (FPS, etc..) \n            if(this.config.debug) {\n                this.stats = new Stats();\n                this.stats.dom.style.top = 'inherit';\n                this.stats.dom.style.bottom = '0px';\n                this.stats.dom.style.left = 'inherit';\n                this.stats.dom.style.right = '0px';\n                document.body.appendChild(this.stats.dom);\n                this.stats.showPanel(0);\n            }\n\n            this.normalizeColor();\n            this.organizeLR();\n            this.initScene();\n            \n            //load tracts and surfaces in parallel\n            await Promise.all([\n                this.loadTracts(), \n                this.loadSurfaces()\n            ]);\n\n            //remove loading indicator\n            this.loading = null;\n            this.load_percentage = 1;\n            \n        },\n\n        async loadTracts() {\n            if(!this.config.tracts) return;\n\n            const textureLoader = new THREE.TextureLoader();\n            const pointSprite = textureLoader.load('point.png');\n\n            let idx = 0;\n            let tracts = new THREE.Object3D();\n            three.scene.add(tracts);\n            for (const tract of this.config.tracts) {\n                this.loading = tract.name;\n                this.load_percentage = (idx++) / this.config.tracts.length;\n                const {lineGeometry, startPointGeometry, endPointGeometry} : any = await this.loadTract(tract);\n\n                //create fiber mesh\n                let normal_material = new THREE.LineBasicMaterial({color: tract.color, transparent: true, linewidth: 1, opacity: 0.6});\n                let highlight_material = new THREE.LineBasicMaterial({color: \"white\", transparent: true, linewidth: 1, opacity: 0.5});\n                const linemesh = new THREE.LineSegments( lineGeometry, normal_material );            \n\n                tract.mesh = linemesh;\n                tract.normal_material = normal_material;\n                tract.highlight_material = highlight_material;\n\n                linemesh.name = tract.name;\n                linemesh.visible = false; //tract.show || false;\n                linemesh.rotation.x = -Math.PI/2;\n                tracts.add(linemesh);\n\n                //create start point particles\n                const startPointMaterial = new THREE.PointsMaterial( { \n                    size: 2, \n                    opacity: 0.5,\n                    map: pointSprite, \n                    blending: THREE.AdditiveBlending, \n                    depthTest: false, \n                    transparent: true } );\n                startPointMaterial.color.setHSL( 0.5, 0.5, 0.3 ); //blue\n                const startPoints = new THREE.Points(startPointGeometry, startPointMaterial);\n                startPoints.visible = false; //tract.show || false;\n                startPoints.rotation.x = -Math.PI/2;\n                tracts.add(startPoints);\n                tract.start = startPoints; \n                \n                //create end point particles\n                const endPointMaterial = new THREE.PointsMaterial( { \n                    size: 2, \n                    opacity: 0.5,\n                    map: pointSprite, \n                    blending: THREE.AdditiveBlending, \n                    depthTest: false, \n                    transparent: true } );\n                endPointMaterial.color.setHSL( 0, 0.5, 0.3 ); //red\n                const endPoints = new THREE.Points(endPointGeometry, endPointMaterial);\n                endPoints.visible = false; //tract.show || false;\n                endPoints.rotation.x = -Math.PI/2;\n                tracts.add(endPoints);\n                tract.end = endPoints;\n            }\n        },\n\n        loadTract(tract: ITractConfig) {\n\n            return new Promise((resolve, reject)=>{\n                if(!tract.url) return; //for ts..\n\n                //use web worker to parse the json.. although I still have to spend good chunk of time constructing the BufferGeometry which\n                //must happen on this thread - as they are not serializable.\n                fetch(tract.url).then(res=>res.json()).then(json=>{\n\n                    // @ts-ignore\n                    this.$worker.run((json:any)=>{\n                        let bundle = json.coords;\n\n                        //normalize data format (1>N>3>[] v.s. N>1>3>[])\n                        if(bundle.length == 1 && bundle[0][0].length == 3) bundle = bundle[0];\n\n                        //convert each bundle to threads_pos array\n                        const threads_pos = [] as number[];\n                        const starts = [] as number[];\n                        const ends = [] as number[];\n                        bundle.forEach((fascicle : number[][])=>{\n                            //normalize data type from the [ [[...]], [[...]], [[...]] ]  into > [ [...],[...],[...] ] \n                            if (fascicle.length == 1 && fascicle[0].length == 3) {\n                                // @ts-ignore\n                                fascicle = fascicle[0]; \n                            }\n\n                            var xs = fascicle[0];\n                            var ys = fascicle[1];\n                            var zs = fascicle[2];\n                            const l = xs.length;\n\n                            starts.push(xs[0], ys[0], zs[0]);\n                            ends.push(xs[l-1], ys[l-1], zs[l-1]);\n\n                            for(var i = 1;i < xs.length;++i) {\n                                threads_pos.push(xs[i-1]);\n                                threads_pos.push(ys[i-1]);\n                                threads_pos.push(zs[i-1]);\n                                threads_pos.push(xs[i]);\n                                threads_pos.push(ys[i]);\n                                threads_pos.push(zs[i]);\n                            }\n                        });\n\n                        return {\n                            lines: new Float32Array(threads_pos),\n                            startPoints: new Float32Array(starts),\n                            endPoints: new Float32Array(ends),\n                        }\n\n                    }, [json]).then((res:any)=>{\n                        let {lines, startPoints, endPoints} = res;\n\n                        //create LineGeometry\n                        const lineGeometry = new THREE.BufferGeometry();\n                        lineGeometry.setAttribute('position', new THREE.BufferAttribute(lines, 3));\n\n                        //start points\n                        const startPointGeometry = new THREE.BufferGeometry();\n                        startPointGeometry.setAttribute('position', new THREE.BufferAttribute(startPoints, 3));\n\n                        //end points\n                        const endPointGeometry = new THREE.BufferGeometry();\n                        endPointGeometry.setAttribute('position', new THREE.BufferAttribute(endPoints, 3));\n\n                        resolve({lineGeometry, startPointGeometry, endPointGeometry});\n                    });\n                });\n\n            });\n        },\n\n        async loadSurfaces() {\n            if(!this.config.surfaces) return;\n\n            let idx = 0;\n            let vtkloader = new VTKLoader();\n            for (const surface of this.config.surfaces) {\n                if(!surface.url) continue;\n\n                this.loading = surface.name;\n                this.load_percentage = (idx++) / this.config.surfaces.length;\n                //await this.loadSurface(surface);\n                try {\n                    const geometry = await vtkloader.loadAsync(surface.url);\n                    geometry.computeVertexNormals(); //for smooth shading\n\n                    // @ts-ignore\n                    if(geometry.computeBoundsTree) geometry.computeBoundsTree(); //for BVH\n                    console.dir(surface.name);\n                    if(surface.name.toLowerCase().includes(\"cerebral\") || surface.name == \"CC\") {\n                        let back_material = new THREE.MeshLambertMaterial({\n                            //color: new THREE.Color(surface.color).multiplyScalar(0),\n                            //color: surface.color,\n                            color: new THREE.Color(0,0,0),\n                            transparent: true,\n                            opacity: 0.2,\n                            depthTest: false,\n                        });\n                        let back_mesh = new THREE.Mesh( geometry, back_material );\n                        back_mesh.rotation.x = -Math.PI/2;\n                        back_mesh.renderOrder = -1; //requires depthTest:false\n                        three.scene.add(back_mesh);\n                    }\n\n                    let mesh = new THREE.Mesh( geometry );\n                    mesh.rotation.x = -Math.PI/2;\n                    mesh.visible = false;\n                    surface.mesh = mesh;\n\n                    //store other surfaces\n                    surface.normal_material = new THREE.MeshLambertMaterial({\n                        color: new THREE.Color(surface.color),\n                        transparent: true,\n                        opacity: 0.8,\n                        //depthTest: false, //need this to show tracts on top\n                    });\n                    surface.highlight_material = new THREE.MeshPhongMaterial({\n                        color: new THREE.Color(surface.color).multiplyScalar(1.25),\n                        transparent: true,\n                        //opacity: 1,\n                        //shininess: 80,\n                        //depthTest: false, //need this to show tracts on top\n                    });\n                    surface.xray_material = new THREE.MeshLambertMaterial({\n                        color: new THREE.Color(surface.color).multiplyScalar(1.25),\n                        transparent: true,\n                        opacity: 0.2,\n                        depthTest: false, //need this to show tracts on top\n                    });\n                    mesh.material = surface.normal_material;\n                    three.scene.add(mesh);\n                } catch (err) {\n                    console.error(\"failed to load surface\", surface.url);\n                    console.error(err);\n                }\n            }\n        },\n\n        loadDemoConfig() {\n            let dataurl = \"/ui/tractview/testdata/0001\"; //production demo data\n            if(this.config.debug) {\n                //dataurl = \"https://brainlife.io/ui/tractview/testdata/0001\";\n                //dataurl = \"testdata/0001\";\n                //dataurl = \"testdata/empty\";\n                dataurl = \"testdata/tractseg\";\n            }\n\n            console.log(\"loading demo tracts.json from\", dataurl + \"/tracts/tracts.json\")\n            fetch(dataurl+\"/tracts/tracts.json\").then(res=>res.json()).then(data=>{\n                if(!Array.isArray(data)) data = [data];\n                this.config.tracts = data;\n                if(this.config.tracts) this.config.tracts.forEach((tract:ITractConfig)=>{\n                    tract.url = dataurl+\"/tracts/\"+tract.filename;\n                });\n                fetch(dataurl+\"/surfaces/index.json\").then(res=>res.json()).then(data=>{\n                    if(!Array.isArray(data)) data = [data];\n                    this.config.surfaces = data;\n                    if(this.config.surfaces) this.config.surfaces.forEach((surface:ISurfaceConfig)=>{\n                        surface.url = dataurl+\"/surfaces/\"+surface.filename;\n                    });\n                    this.init();\n                }).catch(err=>{\n                    //probably no surfacess.. but it's ok\n                    console.error(err);\n                    this.init();\n                });\n            });\n        },\n\n        //convert color info stored in JSON to THREE.Color.\n        normalizeColor()  {\n            if(this.config.tracts) this.config.tracts.forEach((tract:ITractConfig)=>{\n                // @ts-ignore\n                tract.color = new THREE.Color(tract.color[0]/2+0.5, tract.color[1]/2+0.5, tract.color[2]/2+0.5); //always array?\n            });\n            if(this.config.surfaces) this.config.surfaces.forEach((surface:ISurfaceConfig)=>{\n                if(Array.isArray(surface.color)) {\n                surface.color = new THREE.Color(surface.color[0]/2+0.5, surface.color[1]/2+0.5, surface.color[2]/2+0.5); //always array?\n                } else {\n                    surface.color = new THREE.Color(surface.color.r/512+0.5,  surface.color.g/512+0.5,  surface.color.b/512+0.5);  \n                }\n            });\n        },\n\n        //from the config tracts/surfaces, setup this.tracts and this.surfaces with left/right separated (no mesh yet)\n        organizeLR() {\n            this.tracts = {};\n            if(this.config.tracts) this.config.tracts.forEach((tract:ITractConfig)=>{\n                let left = false;\n                let right = false;\n\n                //detect hierachy and adjust name\n                let name = tract.name.toLowerCase();\n                if(name.startsWith('left')) {\n                    left = true;\n                    name = tract.name.substring(4);\n                }\n                if(name.endsWith(' l')) {\n                    left = true;\n                    name = tract.name.substring(0, name.length - 2);\n                }\n                if(name.startsWith('right')) {\n                    right = true;\n                    name = tract.name.substring(5);\n                }\n                if(name.endsWith(' r')) {\n                    right = true;\n                    name = tract.name.substring(0, name.length - 2);\n                }\n\n                //if it's not left nor right, pretend that it's left\n                if(!left && !right) left = true;\n\n                //put tract info into appropriate categories\n                if(!this.tracts[name]) this.tracts[name] = {\n                    left_check: false,\n                    right_check: false,\n                }\n\n                if(left) this.tracts[name].left = tract;\n                if(right) this.tracts[name].right = tract;\n            });\n\n            this.surfaces = {};\n            if(this.config.surfaces) this.config.surfaces.forEach((surface:ISurfaceConfig)=>{\n                let left = false;\n                let right = false;\n\n                //detect hierachy and adjust name\n                let name = surface.name.toLowerCase();\n                //console.log(name);\n                if(name.startsWith('left-')) {\n                    left = true;\n                    name = surface.name.substring(5);\n                }\n                if(name.endsWith('_left')) {\n                    left = true;\n                    name = surface.name.substring(0, name.length-5);\n                }\n                if(name.startsWith('l-')) {\n                    left = true;\n                    name = surface.name.substring(2);\n                }\n                if(name.startsWith('right-')) {\n                    right = true;\n                    name = surface.name.substring(6);\n                }\n                if(name.endsWith('_right')) {\n                    right = true;\n                    name = surface.name.substring(0, name.length-6);\n                }\n                if(name.startsWith('r-')) {\n                    right = true;\n                    name = surface.name.substring(2);\n                }\n                if(name.includes('-lh-')) {\n                    left = true;\n                    name = surface.name.replace(\"-lh-\", \"-\");\n                }\n                if(name.includes('-rh-')) {\n                    right = true;\n                    name = surface.name.replace(\"-rh-\", \"-\");\n                }\n                if(name.includes('_lh_')) {\n                    left = true;\n                    name = surface.name.replace(\"_lh_\", \"-\");\n                }\n                if(name.includes('_rh_')) {\n                    right = true;\n                    name = surface.name.replace(\"_rh_\", \"-\");\n                }\n\n                //if it's not left nor right, pretend that it's left\n                if(!left && !right) left = true;\n\n                //put tract info into appropriate categories\n                if(!this.surfaces[name]) this.surfaces[name] = {\n                    left_check: false,\n                    right_check: false,\n                }\n\n                if(left) this.surfaces[name].left = surface;\n                if(right) this.surfaces[name].right = surface;\n            });\n        },\n\n        initScene() {\n\n            // @ts-ignore\n            let viewbox = this.$refs.view.getBoundingClientRect();\n\n            three.renderer.autoClear = false;\n            three.renderer.setSize(viewbox.width, viewbox.height);\n\n            // @ts-ignore\n            this.$refs.view.appendChild(three.renderer.domElement);\n\n            three.camera.position.z = 200;\n            //three.back_scene.add(new THREE.AmbientLight(0xffffff));\n            //three.back_scene.add(three.camera_light);\n\n            three.scene.add(new THREE.AmbientLight(0x808080));\n            three.scene.add(three.camera_light);\n\n            this.controls.orbit = new OrbitControls(three.camera, three.renderer.domElement);\n            this.controls.orbit.enableDamping = true;\n            this.controls.orbit.dampingFactor = 0.25;\n    \n            three.scene.add( new THREE.AxesHelper( 50 ) );\n            //three.scene.add( new THREE.GridHelper(200, 20) );\n\n            window.addEventListener(\"resize\", this.resize);\n            this.resize();\n\n            three.renderer.setAnimationLoop(this.animate); //start animating before all data is loaded\n        },\n\n        resize() {\n            // @ts-ignore\n            const viewbox = this.$refs.view.getBoundingClientRect();\n            three.camera.aspect = viewbox.width / viewbox.height;\n            three.camera.updateProjectionMatrix();\n            three.renderer.setSize(viewbox.width, viewbox.height);\n        },\n\n        animate() {\n            if(this.stats) this.stats.begin();\n\n            if(this.controls.orbit) this.controls.orbit.update();\n\n            // @ts-ignore (can't figure out what's wrong with animate_mesh param)\n            if(this.hoveredLR?.left?.mesh) this.animateMesh(this.hoveredLR.left.mesh);\n            // @ts-ignore (can't figure out what's wrong with animate_mesh param)\n            if(this.hoveredLR?.right?.mesh) this.animateMesh(this.hoveredLR.right.mesh);       \n\n            three.camera_light.position.copy(three.camera.position);\n\n            three.renderer.clear();\n            //three.renderer.render(three.back_scene, three.camera);\n            //three.renderer.clearDepth();\n            three.renderer.render(three.scene, three.camera);\n\n            if(this.stats) this.stats.end();\n\n            //requestAnimationFrame(this.animate);\n        },\n\n        animateMesh(mesh : THREE.Mesh) {\n            const now = new Date().getTime();\n            const l = Math.cos((now/5%1000)*(2*Math.PI/1000)); //-1.0 ~ -1.0 (every 5 seconds)\n            (mesh.material as THREE.Material).opacity = Math.abs(l)/2+0.1;  //0.1 ~ 0.7\n        },\n\n        menuitementer(obj: (ITractLR|ISurfaceLR)) {\n            if(obj.left && obj.left.mesh) {\n                obj.left.mesh.material = obj.left.highlight_material;\n                obj.left.mesh.visible = true;\n            }\n            if(obj.right && obj.right.mesh) {\n                obj.right.mesh.material = obj.right.highlight_material;\n                obj.right.mesh.visible = true;\n            }\n            this.updateVisibility();\n\n            this.hoveredLR = obj;\n        },\n\n        menuitemleave(obj: (ITractLR|ISurfaceLR)) {\n            if(obj.left && obj.left.mesh) {\n                obj.left.mesh.material = obj.left.normal_material;\n                if(!obj.left_check) obj.left.mesh.visible = false;\n            }\n            if(obj.right && obj.right.mesh) {\n                obj.right.mesh.material = obj.right.normal_material;\n                if(!obj.right_check) obj.right.mesh.visible = false;\n            }\n            this.updateVisibility();\n            this.hoveredLR = null;\n        },\n\n        mouseup(/*event*/) {\n            if(this.pushed_surface?.mesh) {\n                this.pushed_surface.mesh.material = this.pushed_surface.normal_material;\n                this.pushed_surface = null;\n            }\n            this.tooltip = \"\";\n        },\n\n        mousedown(event: MouseEvent) {\n            let obj = this.findSurface(event);\n            if(obj?.mesh) {\n                this.pushed_surface = obj;\n                obj.mesh.material = obj.xray_material;\n            }\n        },\n\n        mousemove(event: MouseEvent) {\n            this.tooltip = \"\";\n            if(this.tooltipBounce) clearTimeout(this.tooltipBounce);\n            this.tooltipBounce = setTimeout(()=>{\n                let obj = this.findSurface(event);\n                if(obj) {\n                    this.tooltip = obj.name;\n                    (this.$refs.tooltip as HTMLElement).style.left = event.x+\"px\";\n                    (this.$refs.tooltip as HTMLElement).style.top = (event.y-30)+\"px\";\n                }\n            }, 300)\n        },\n\n        findSurface(event: MouseEvent): ISurfaceConfig|null {\n            if(!this.config.surfaces) return null;\n            \n            let mouse = new THREE.Vector2();\n            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n            three.raycaster.setFromCamera( mouse, three.camera );\n\n            //console.time(\"raycasting\");\n            let intersects = three.raycaster.intersectObjects(three.scene.children);\n            //console.timeEnd(\"raycasting\");\n\n            /* each intersects will contain..\n            distance: 123.30349997883842\n            face: {a: 4878, b: 5089, c: 4877, normal: Vector3, materialIndex: 0}\n            faceIndex: 1187\n            object: Mesh {uuid: '134C723D-6261-4C2A-87CF-CED307926FFD', name: '', type: 'Mesh', parent: Scene, children: Array(0), …}\n            point: Vector3\n            x: 3.7158954185774817\n            y: 39.11251489116937\n            z: 74.70316006686787\n            */\n\n            //select first surface mesh\n            for(let i = 0;i < intersects.length; ++i) {\n                let mesh = intersects[i].object as THREE.Mesh;\n                const surface = this.config.surfaces.find(s=>(s.mesh?.visible && s.mesh?.uuid == mesh.uuid));\n                if(surface) return surface;\n            }\n            return null;\n        },\n\n        updateVisibility() {\n            for(let name in this.tracts) {\n                let tract = this.tracts[name] as ITractLR;\n                if(tract.left && tract.left.mesh) {\n                    tract.left.start.visible = tract.left.mesh.visible && this.controls.showStart;\n                    tract.left.end.visible = tract.left.mesh.visible && this.controls.showEnd;\n                }\n                if(tract.right && tract.right.mesh) {\n                    tract.right.start.visible = tract.right.mesh.visible && this.controls.showStart;\n                    tract.right.end.visible = tract.right.mesh.visible && this.controls.showEnd;\n                }\n            }\n        },\n    },\n\n    components: {\n        SurfaceController,\n        TractController,\n    }\n});\n\n</script>\n\n<template>\n<span class=\"loading\" v-if=\"!config.tracts\">Loading Config</span>\n<div v-if=\"config.tracts\" class=\"main\">\n    <div class=\"tooltip\" ref=\"tooltip\" v-show=\"tooltip\">{{tooltip}}</div>\n    <div class=\"view\" ref=\"view\" @mousedown=\"mousedown\" @mouseup=\"mouseup\" @mousemove=\"mousemove\"/>\n\n    <div v-if=\"load_percentage < 1\" id=\"loading\" class=\"loading\">Loading... {{loading}} ({{Math.round(load_percentage*100)}}%)</div>\n\n    <SurfaceController :surfaces=\"surfaces\" \n        @menuitementer=\"menuitementer\" \n        @menuitemleave=\"menuitemleave\" \n        @update=\"updateVisibility\"/>\n    <TractController :tracts=\"tracts\" \n        @menuitementer=\"menuitementer\" \n        @menuitemleave=\"menuitemleave\" \n        @update=\"updateVisibility\"/>\n\n    <div class=\"controls-help\">\n        <span>Rotate</span>\n        <span>Zoom</span>\n        <span>Pan</span>\n        <br>\n        <img src=\"./assets/controls.png\" style=\"height: 40px\"/>\n    </div>\n\n    <div class=\"rotateControl\">\n        <input type=\"checkbox\" v-if=\"controls.orbit\" v-model=\"controls.orbit.autoRotate\" >\n        &nbsp;\n        <span>Auto-Rotate</span>\n        &nbsp;\n        <input type=\"checkbox\" v-model=\"controls.showStart\">\n        &nbsp;\n        <span style=\"color: #5cf\">Show Fiber Startpoint</span>\n        &nbsp;\n        <input type=\"checkbox\" v-model=\"controls.showEnd\">\n        &nbsp;\n        <span style=\"color: #f55\">Show Fiber Endpoint</span>\n        &nbsp;\n    </div>\n</div>\n</template>\n\n<style lang=\"scss\">\n@import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');\n\nhtml, body {\n    height: 100%;\n    margin: 0;\n    font-family: Roboto;\n    font-size: 12px;\n    color: white;\n}\n\n.controls {\n    position: fixed;\n    top: 0;\n    bottom: 0;\n    width:250px;\n    white-space:nowrap;\n    background:rgba(0, 0, 0, .3);\n    color: #fff;\n    user-select: none;\n\n    h2 {\n        font-size: 13pt;\n        opacity: 0.5;\n        color: white;\n        margin-bottom: 3px;\n    }\n\n    .control-row {\n        height: 17px;\n        padding-left: 10px;\n\n    }\n\n    .control-row:hover {\n        background-color: rgba(0,0,0,0.3);\n        color: white !important;\n    }\n\n    .check {\n        position: absolute;\n        opacity: 0.6;\n    }\n\n    .check-left {\n        right: 35px;\n    }\n\n    .check-right {\n        right: 15px;\n    }\n}\n\n.scrollable {\n    position: fixed;\n    width: 250px;\n    top: 35px;\n    bottom: 0;\n}\n\n#app {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    position: relative;\n}\n\n</style>\n\n<style lang=\"scss\" scoped>\n\n.main {\n    width: 100%;\n    height: 100%;\n}\n\n.error {\n    position:relative;\n    width:100%;\n    height:100%;\n    background:black;\n    color:white;\n    padding:10px;\n    font-size:20px;\n}\n\n.view {\n    width: 100%;\n    height: 100%;\n    background: #333;\n    position: absoute;\n}\n\ninput[type=\"checkbox\"] {\n    vertical-align:middle;\n    margin:0;\n    cursor:pointer;\n}\n\n.bllogo {\n    position: fixed;\n    padding: 8px;\n    font-size: 23px;\n    font-family: \"Open Sans\";\n    font-weight: bold;\n    opacity:.3;\n    color:white;\n    text-decoration:none;\n    bottom: 0px;\n    right: 0px;\n}\n\n.loading {\n    position: fixed;\n    width: 100%;\n    bottom:150px;\n    color:white;\n    opacity:.2;\n    text-align: center;\n    pointer-events: none;\n    font-size: 200%;\n}\n\n.rotateControl {\n    position: fixed;\n    bottom: 5px;\n    left: 260px;\n}\n.controls-help {\n    color: white;\n    position: fixed;\n    bottom: 5px;\n    right: 255px;\n    opacity: 0.7;\n}\n.controls-help span {\n    font-size: 6pt;\n    width: 27px;\n    display: inline-block;\n    text-align: center;\n}\n.tooltip {\n    position: absolute;\n    z-index: 1;\n    background-color: #0008;\n    display: inline-block;\n    padding: 5px;\n}\n\n</style>\n","export default \"__VITE_ASSET__461493e5__\"","import { createApp } from 'vue'\n\nimport App from './App.vue'\n\n// @ts-ignore\nimport SimpleWebWorker from 'simple-web-worker'\n\nconst app = createApp(App);\napp.config.globalProperties.$worker = SimpleWebWorker;\n\napp.mount('#app')\n"],"names":["relList","document","createElement","supports","link","querySelectorAll","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","ep","fetchOpts","script","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","href","p","defineComponent","props","surfaces","Object","required","mounted","PerfectScrollbar","this","$refs","methods","color","surface","left","getStyle","right","menuitementer","tract","$emit","menuitemleave","check","obj","mesh","visible","left_check","right_check","tracts","data","all_left","all_right","computed","sorted_tracts","keys","sort","watch","v","name","three","scene","THREE.Scene","renderer","THREE.WebGLRenderer","alpha","antialias","camera","THREE.PerspectiveCamera","camera_light","THREE.PointLight","raycaster","THREE.Raycaster","config","debug","controls","orbit","showStart","showEnd","load_percentage","loading","pushed_surface","hoveredLR","tooltip","tooltipBounce","stats","window","parent","Array","isArray","jwt","localStorage","getItem","forEach","url","$nextTick","init","loadDemoConfig","destroyed","removeEventListener","resize","updateVisibility","prototype","computeBoundsTree","disposeBoundsTree","raycast","acceleratedRaycast","Stats","dom","style","top","bottom","body","appendChild","showPanel","normalizeColor","organizeLR","initScene","Promise","all","loadTracts","loadSurfaces","pointSprite","THREE.TextureLoader","load","idx","THREE.Object3D","add","length","lineGeometry","startPointGeometry","endPointGeometry","loadTract","normal_material","THREE.LineBasicMaterial","transparent","linewidth","opacity","highlight_material","linemesh","THREE.LineSegments","rotation","x","Math","PI","startPointMaterial","THREE.PointsMaterial","size","map","blending","THREE.AdditiveBlending","depthTest","setHSL","startPoints","THREE.Points","start","endPointMaterial","endPoints","end","resolve","reject","then","res","json","$worker","run","json2","bundle","coords","threads_pos","starts","ends","fascicle","xs","ys","zs","l","push","i","lines","Float32Array","THREE.BufferGeometry","setAttribute","THREE.BufferAttribute","vtkloader","VTKLoader","geometry","loadAsync","computeVertexNormals","dir","toLowerCase","includes","back_material","THREE.MeshLambertMaterial","THREE.Color","back_mesh","THREE.Mesh","renderOrder","THREE.MeshPhongMaterial","multiplyScalar","xray_material","material","err","error","dataurl","log","filename","data2","catch","r","g","b","startsWith","substring","endsWith","replace","viewbox","view","getBoundingClientRect","autoClear","setSize","width","height","domElement","position","z","THREE.AmbientLight","OrbitControls","enableDamping","dampingFactor","THREE.AxesHelper","addEventListener","setAnimationLoop","animate","aspect","updateProjectionMatrix","begin","update","animateMesh","copy","clear","render","now","Date","getTime","cos","abs","mouseup","mousedown","event","findSurface","mousemove","setTimeout","y","mouse","THREE.Vector2","clientX","innerWidth","clientY","innerHeight","setFromCamera","intersects","intersectObjects","children","object","find","uuid","components","SurfaceController","TractController","app","createApp","App","globalProperties","SimpleWebWorker","mount"],"mappings":"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"}